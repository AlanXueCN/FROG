(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[30],{

/***/ "../node_modules/@material-ui/icons/Replay.js":
/*!****************************************************!*\
  !*** ../node_modules/@material-ui/icons/Replay.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"../node_modules/@material-ui/icons/node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"../node_modules/react/index.js\"));\n\nvar _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ \"../node_modules/@material-ui/icons/utils/createSvgIcon.js\"));\n\nvar _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0z\"\n}), _react.default.createElement(\"path\", {\n  d: \"M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z\"\n})), 'Replay');\n\nexports.default = _default;\n\n//# sourceURL=webpack:///../node_modules/@material-ui/icons/Replay.js?");

/***/ }),

/***/ "../node_modules/statsjs/lib/stats.js":
/*!********************************************!*\
  !*** ../node_modules/statsjs/lib/stats.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * Stats.js (https://github.com/angusgibbs/stats.js)\r\n * Copyright 2012 Angus Gibbs\r\n */\r\n(function(root) {\r\n\t// Create the top level stats object\r\n\t// =================================\r\n\t\r\n\t// Wrapper to create a chainable stats object.\r\n\t//\r\n\t// arr - The array to work with.\r\n\t//\r\n\t// Returns a new chainable object.\r\n\tvar stats = function(arr) {\r\n\t\treturn new stats.init(arguments.length > 1 ?\r\n\t\t\tArray.prototype.slice.call(arguments, 0) :\r\n\t\t\tarr);\r\n\t};\r\n\r\n\t// Creates a new chainable array object.\r\n\t//\r\n\t// arr - The array to work with.\r\n\t//\r\n\t// Returns a new chainable object.\r\n\tstats.init = function(arr) {\r\n\t\tthis.arr = arr;\r\n\t\tthis.length = arr.length;\r\n\t};\r\n\r\n\t// Define the methods for the stats object\r\n\tstats.init.prototype = {\r\n\t\t// Calls a function on each element in an array or JSON object.\r\n\t\t//\r\n\t\t// fn  - The function to call on each element.\r\n\t\t//       el    - The array or object element\r\n\t\t//       index - The index or key of the array element\r\n\t\t//       arr   - The array or object\r\n\t\t//\r\n\t\t// Returns nothing.\r\n\t\teach: function(fn) {\r\n\t\t\tif (this.arr.length === undefined) {\r\n\t\t\t\t// The wrapped array is a JSON object\r\n\t\t\t\tfor (var key in arr) {\r\n\t\t\t\t\tfn.call(this.arr[key], key, this.arr[key], this.arr);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// The wrapper array is an array\r\n\t\t\t\tfor (var i = 0, l = this.arr.length; i < l; i++) {\r\n\t\t\t\t\tfn.call(this.arr[i], this.arr[i], i, this.arr);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t// Replaces each element in an array or JSON object with the result of\r\n\t\t// the function that is called against each element.\r\n\t\t//\r\n\t\t// fn - The function to call on each element\r\n\t\t//      el    - The array or object element\r\n\t\t//      index - The index or key of the array element\r\n\t\t//\r\n\t\t// Returns nothing.\r\n\t\tmap: function(fn) {\r\n\t\t\tvar arr = this.arr;\r\n\r\n\t\t\tif (arr.length === undefined) {\r\n\t\t\t\t// The wrapped array is a JSON object\r\n\t\t\t\tfor (var key in arr) {\r\n\t\t\t\t\tthis.arr[key] = fn.call(arr[key], arr[key], key, arr);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// The wrapped array is an array\r\n\t\t\t\tfor (var i = 0, l = this.arr.length; i < l; i++) {\r\n\t\t\t\t\tthis.arr[i] = fn.call(arr[i], arr[i], i, arr);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t// Replaces each element of the array with the attribute of that given\r\n\t\t// element.\r\n\t\t//\r\n\t\t// attr - The attribute to pluck.\r\n\t\t//\r\n\t\t// Returns nothing.\r\n\t\tpluck: function(attr) {\r\n\t\t\tvar newArr = [];\r\n\r\n\t\t\tif (this.arr.length === undefined) {\r\n\t\t\t\t// The wrapped array is a JSON object\r\n\t\t\t\tfor (var key in arr) {\r\n\t\t\t\t\tnewArr.push(this.arr[key][attr]);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// The wrapped array is an array\r\n\t\t\t\tfor (var i = 0, l = this.arr.length; i < l; i++) {\r\n\t\t\t\t\tnewArr.push(this.arr[i][attr]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn stats(newArr);\r\n\t\t},\r\n\r\n\t\t// Finds the smallest number.\r\n\t\t//\r\n\t\t// attr - Optional. If passed, the elemnt with the minimum value for the\r\n\t\t//        given attribute will be returned.\r\n\t\t//\r\n\t\t// Returns the minimum.\r\n\t\tmin: function(attr) {\r\n\t\t\t// Get the numbers\r\n\t\t\tvar arr = this.arr;\r\n\r\n\t\t\t// Go through each of the numbers and find the minimum\r\n\t\t\tvar minimum = attr == null ? arr[0] : arr[0][attr];\r\n\t\t\tvar minimumEl = attr == null ? arr[0] : arr[0];\r\n\r\n\t\t\tstats(arr).each(function(num, index) {\r\n\t\t\t\tif ((attr == null ? num : num[attr]) < minimum) {\r\n\t\t\t\t\tminimum = attr == null ? num : num[attr];\r\n\t\t\t\t\tminimumEl = num;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn minimumEl;\r\n\t\t},\r\n\r\n\t\t// Finds the largest number.\r\n\t\t//\r\n\t\t// attr - Optional. If passed, the elemnt with the maximum value for the\r\n\t\t//        given attribute will be returned.\r\n\t\t//\r\n\t\t// Returns the maximum.\r\n\t\tmax: function(attr) {\r\n\t\t\t// Get the numbers\r\n\t\t\tvar arr = this.arr;\r\n\r\n\t\t\t// Go through each of the numbers and find the maximum\r\n\t\t\tvar maximum = attr == null ? arr[0] : arr[0][attr];\r\n\t\t\tvar maximumEl = attr == null ? arr[0] : arr[0];\r\n\r\n\t\t\tstats(arr).each(function(num, index) {\r\n\t\t\t\tif ((attr == null ? num : num[attr]) > maximum) {\r\n\t\t\t\t\tmaximum = attr == null ? num : num[attr];\r\n\t\t\t\t\tmaximumEl = num;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn maximumEl;\r\n\t\t},\r\n\r\n\t\t// Finds the median of the numbers.\r\n\t\t//\r\n\t\t// Returns the median.\r\n\t\tmedian: function() {\r\n\t\t\t// Sort the numbers\r\n\t\t\tvar arr = this.clone().sort().toArray();\r\n\r\n\t\t\tif (arr.length % 2 === 0) {\r\n\t\t\t\t// There are an even number of elements in the array; the median\r\n\t\t\t\t// is the average of the middle two\r\n\t\t\t\treturn (arr[arr.length / 2 - 1] + arr[arr.length / 2]) / 2;\r\n\t\t\t} else {\r\n\t\t\t\t// There are an odd number of elements in the array; the median\r\n\t\t\t\t// is the middle one\r\n\t\t\t\treturn arr[(arr.length - 1) / 2];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Finds the first quartile of the numbers.\r\n\t\t//\r\n\t\t// Returns the first quartile.\r\n\t\tq1: function() {\r\n\t\t\t// Handle the single element case\r\n\t\t\tif (this.length == 1) {\r\n\t\t\t\treturn this.arr[0];\r\n\t\t\t}\r\n\r\n\t\t\t// Sort the numbers\r\n\t\t\tvar nums = this.clone().sort();\r\n\r\n\t\t\t// The first quartile is the median of the lower half of the numbers\r\n\t\t\treturn nums.slice(0, Math.floor(nums.size() / 2)).median();\r\n\t\t},\r\n\r\n\t\t// Finds the third quartile of the numbers.\r\n\t\t//\r\n\t\t// Returns the third quartile.\r\n\t\tq3: function() {\r\n\t\t\t// Handle the single element case\r\n\t\t\tif (this.length == 1) {\r\n\t\t\t\treturn this.arr[0];\r\n\t\t\t}\r\n\r\n\t\t\t// Sort the numbers\r\n\t\t\tvar nums = this.clone().sort();\r\n\r\n\t\t\t// The third quartile is the median of the upper half of the numbers\r\n\t\t\treturn nums.slice(Math.ceil(nums.size() / 2)).median();\r\n\t\t},\r\n\r\n\t\t// Finds the interquartile range of the data set.\r\n\t\t//\r\n\t\t// Returns the IQR.\r\n\t\tiqr: function() {\r\n\t\t\treturn this.q3() - this.q1();\r\n\t\t},\r\n\t\t\t\r\n\t\t// Finds all outliers in the data set, using the 1.5 * IQR away from\r\n\t\t// the median test.\r\n\t\t//\r\n\t\t// Returns a new stats object with the outliers.\r\n\t\tfindOutliers: function() {\r\n\t\t\t// Get the median and the range that the number must fall within\r\n\t\t\tvar median = this.median();\r\n\t\t\tvar range  = this.iqr() * 1.5;\r\n\r\n\t\t\t// Create a new stats object to hold the outliers\r\n\t\t\tvar outliers = stats([]);\r\n\r\n\t\t\t// Go through each element in the data set and test to see if it\r\n\t\t\t// is an outlier\r\n\t\t\tthis.each(function(num) {\r\n\t\t\t\tif (Math.abs(num - median) > range) {\r\n\t\t\t\t\t// The number is an outlier\r\n\t\t\t\t\toutliers.push(num);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn outliers;\r\n\t\t},\r\n\r\n\t\t// Tests if the given number would be an outlier in the data set.\r\n\t\t//\r\n\t\t// num - The number to test.\r\n\t\t//\r\n\t\t// Returns a boolean.\r\n\t\ttestOutlier: function(num) {\r\n\t\t\treturn (Math.abs(num - this.median()) > this.iqr() * 1.5);\r\n\t\t},\r\n\r\n\t\t// Removes all the outliers from the data set.\r\n\t\t//\r\n\t\t// Returns nothing.\r\n\t\tremoveOutliers: function() {\r\n\t\t\t// Get the median and the range that the number must fall within\r\n\t\t\tvar median = this.median();\r\n\t\t\tvar range  = this.iqr() * 1.5;\r\n\r\n\t\t\t// Create a new stats object that will hold all the non-outliers\r\n\t\t\tvar notOutliers = stats([]);\r\n\r\n\t\t\t// Go through each element in the data set and test to see if it\r\n\t\t\t// is an outlier\r\n\t\t\tthis.each(function(num) {\r\n\t\t\t\tif (Math.abs(num - median) <= range) {\r\n\t\t\t\t\t// The number is not an outlier\r\n\t\t\t\t\tnotOutliers.push(num);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn notOutliers;\r\n\t\t},\r\n\r\n\t\t// Finds the mean of the numbers.\r\n\t\t//\r\n\t\t// Returns the mean.\r\n\t\tmean: function() {\r\n\t\t\treturn this.sum() / this.size();\r\n\t\t},\r\n\r\n\t\t// Finds the sum of the numbers.\r\n\t\t//\r\n\t\t// Returns the sum.\r\n\t\tsum: function() {\r\n\t\t\tvar result = 0;\r\n\r\n\t\t\tthis.each(function(num) {\r\n\t\t\t\tresult += num;\r\n\t\t\t});\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\t// Finds the standard deviation of the numbers.\r\n\t\t//\r\n\t\t// Returns the standard deviation.\r\n\t\tstdDev: function() {\r\n\t\t\t// Get the mean\r\n\t\t\tvar mean = this.mean();\r\n\r\n\t\t\t// Get a new stats object to work with\r\n\t\t\tvar nums = this.clone();\r\n\r\n\t\t\t// Map each element of nums to the square of the element minus the\r\n\t\t\t// mean\r\n\t\t\tnums.map(function(num) {\r\n\t\t\t\treturn Math.pow(num - mean, 2);\r\n\t\t\t});\r\n\r\n\t\t\t// Return the standard deviation\r\n\t\t\treturn Math.sqrt(nums.sum() / (nums.size() - 1));\r\n\t\t},\r\n\r\n\t\t// Calculates the correlation coefficient for the data set.\r\n\t\t//\r\n\t\t// Returns the value of r.\r\n\t\tr: function() {\r\n\t\t\t// Get the x and y coordinates\r\n\t\t\tvar xCoords = this.pluck('x');\r\n\t\t\tvar yCoords = this.pluck('y');\r\n\r\n\t\t\t// Get the means for the x and y coordinates\r\n\t\t\tvar meanX = xCoords.mean();\r\n\t\t\tvar meanY = yCoords.mean();\r\n\r\n\t\t\t// Get the standard deviations for the x and y coordinates\r\n\t\t\tvar stdDevX = xCoords.stdDev();\r\n\t\t\tvar stdDevY = yCoords.stdDev();\r\n\r\n\t\t\t// Map each element to the difference of the element and the mean\r\n\t\t\t// divided by the standard deviation\r\n\t\t\txCoords.map(function(num) {\r\n\t\t\t\treturn (num - meanX) / stdDevX;\r\n\t\t\t});\r\n\t\t\tyCoords.map(function(num) {\r\n\t\t\t\treturn (num - meanY) / stdDevY;\r\n\t\t\t});\r\n\r\n\t\t\t// Multiply each element in the x by the corresponding value in\r\n\t\t\t// the y\r\n\t\t\tvar nums = this.clone().map(function(num, index) {\r\n\t\t\t\treturn xCoords.get(index) * yCoords.get(index);\r\n\t\t\t});\r\n\r\n\t\t\t// r is the sum of xCoords over the number of points minus 1\r\n\t\t\treturn nums.sum() / (nums.size() - 1);\r\n\t\t},\r\n\r\n\t\t// Calculates the Least Squares Regression line for the data set.\r\n\t\t//\r\n\t\t// Returns an object with the slope and y intercept.\r\n\t\tlinReg: function() {\r\n\t\t\t// Get the x and y coordinates\r\n\t\t\tvar xCoords = this.pluck('x');\r\n\t\t\tvar yCoords = this.pluck('y');\r\n\r\n\t\t\t// Get the means for the x and y coordinates\r\n\t\t\tvar meanX = xCoords.mean();\r\n\t\t\tvar meanY = yCoords.mean();\r\n\r\n\t\t\t// Get the standard deviations for the x and y coordinates\r\n\t\t\tvar stdDevX = xCoords.stdDev();\r\n\t\t\tvar stdDevY = yCoords.stdDev();\r\n\r\n\t\t\t// Calculate the correlation coefficient\r\n\t\t\tvar r = this.r();\r\n\r\n\t\t\t// Calculate the slope\r\n\t\t\tvar slope = r * (stdDevY / stdDevX);\r\n\r\n\t\t\t// Calculate the y-intercept\r\n\t\t\tvar yIntercept = meanY - slope * meanX;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tslope: slope,\r\n\t\t\t\tyIntercept: yIntercept,\r\n\t\t\t\tr: r\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t// Calculates the exponential regression line for the data set.\r\n\t\t//\r\n\t\t// Returns an object with the coefficient, base, and correlation\r\n\t\t// coefficient for the linearized data.\r\n\t\texpReg: function() {\r\n\t\t\t// Get y coordinates\r\n\t\t\tvar yCoords = this.pluck('y');\r\n\r\n\t\t\t// Do a semi-log transformation of the coordinates\r\n\t\t\tyCoords.map(function(num) {\r\n\t\t\t\treturn Math.log(num);\r\n\t\t\t});\r\n\r\n\t\t\t// Get a new stats object to work with that has the transformed data\r\n\t\t\tvar nums = this.clone().map(function(coord, index) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tx: coord.x,\r\n\t\t\t\t\ty: yCoords.get(index)\r\n\t\t\t\t};\r\n\t\t\t});\r\n\r\n\t\t\t// Calculate the linear regression for the linearized data\r\n\t\t\tvar linReg = nums.linReg();\r\n\r\n\t\t\t// Calculate the coefficient for the exponential equation\r\n\t\t\tvar coefficient = Math.pow(Math.E, linReg.yIntercept);\r\n\r\n\t\t\t// Calculate the base for the exponential equation\r\n\t\t\tvar base = Math.pow(Math.E, linReg.slope);\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcoefficient: coefficient,\r\n\t\t\t\tbase: base,\r\n\t\t\t\tr: linReg.r\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t// Calculates the power regression line for the data set.\r\n\t\t//\r\n\t\t// Returns an object with the coefficient, base, and correlation\r\n\t\t// coefficient for the linearized data.\r\n\t\tpowReg: function() {\r\n\t\t\t// Get y coordinates\r\n\t\t\tvar xCoords = this.pluck('x');\r\n\t\t\tvar yCoords = this.pluck('y');\r\n\r\n\t\t\t// Do a log-log transformation of the coordinates\r\n\t\t\txCoords.map(function(num) {\r\n\t\t\t\treturn Math.log(num);\r\n\t\t\t});\r\n\t\t\tyCoords.map(function(num) {\r\n\t\t\t\treturn Math.log(num);\r\n\t\t\t});\r\n\r\n\t\t\t// Get a new stats object to work with that has the transformed data\r\n\t\t\tvar nums = this.clone().map(function(coord, index) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tx: xCoords.get(index),\r\n\t\t\t\t\ty: yCoords.get(index)\r\n\t\t\t\t};\r\n\t\t\t});\r\n\r\n\t\t\t// Calculate the linear regression for the linearized data\r\n\t\t\tvar linReg = nums.linReg();\r\n\r\n\t\t\t// Calculate the coefficient for the power equation\r\n\t\t\tvar coefficient = Math.pow(Math.E, linReg.yIntercept);\r\n\r\n\t\t\t// Calculate the exponent for the power equation\r\n\t\t\tvar exponent = linReg.slope;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcoefficient: coefficient,\r\n\t\t\t\texponent: exponent,\r\n\t\t\t\tr: linReg.r\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t// Returns the number of elements.\r\n\t\tsize: function() {\r\n\t\t\treturn this.arr.length;\r\n\t\t},\r\n\r\n\t\t// Clones the current stats object, providing a new stats object which\r\n\t\t// can be changed without modifying the original object.\r\n\t\t//\r\n\t\t// Returns a new stats object.\r\n\t\tclone: function() {\r\n\t\t\treturn stats(this.arr.slice(0));\r\n\t\t},\r\n\r\n\t\t// Sorts the internal array, optionally by an attribute.\r\n\t\t//\r\n\t\t// attr - The attribute of the JSON object to sort by. (Optional.)\r\n\t\t//\r\n\t\t// Returns nothing.\r\n\t\tsort: function(attr) {\r\n\t\t\t// Create the sort function\r\n\t\t\tvar sortFn;\r\n\r\n\t\t\t// CASE: Simple ascending sort\r\n\t\t\tif (attr == null) {\r\n\t\t\t\tsortFn = function(a, b) { return a - b; };\r\n\t\t\t}\r\n\t\t\t// CASE: Simple descending sort\r\n\t\t\telse if (attr === true) {\r\n\t\t\t\tsortFn = function(a, b) { return b - a; };\r\n\t\t\t}\r\n\t\t\t// CASE: Sort by an attribute\r\n\t\t\telse if (typeof attr === 'string') {\r\n\t\t\t\tsortFn = function(a, b) { return a[attr] - b[attr]; };\r\n\t\t\t}\r\n\t\t\t// CASE: Sort by a function\r\n\t\t\telse {\r\n\t\t\t\tsortFn = attr;\r\n\t\t\t}\r\n\r\n\t\t\tthis.arr = this.arr.sort(sortFn);\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t// Gets an element from the object.\r\n\t\t//\r\n\t\t// i - The index to retrieve.\r\n\t\t//\r\n\t\t// Returns the element at that index.\r\n\t\tget: function(i) {\r\n\t\t\treturn this.arr[i];\r\n\t\t},\r\n\r\n\t\t// Sets an element on the object.\r\n\t\t//\r\n\t\t// i   - The index to set.\r\n\t\t// val - The value to set the index to.\r\n\t\t//\r\n\t\t// Returns nothing.\r\n\t\tset: function(i, val) {\r\n\t\t\tthis.arr[i] = val;\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t// Calculates the greatest common divisor of the set.\r\n\t\t//\r\n\t\t// Returns a Number, the gcd.\r\n\t\tgcd: function() {\r\n\t\t\t// Create a new stats object to work with\r\n\t\t\tvar nums = this.clone();\r\n\r\n\t\t\t// Go through each element and make the element the gcd of it\r\n\t\t\t// and the element to its left\r\n\t\t\tfor (var i = 1; i < nums.size(); i++) {\r\n\t\t\t\tnums.set(i, gcd(nums.get(i - 1), nums.get(i)));\r\n\t\t\t}\r\n\r\n\t\t\t// The gcd of all the numbers is now in the final element\r\n\t\t\treturn nums.get(nums.size() - 1);\r\n\t\t},\r\n\r\n\t\t// Calculates the least common multiple of the set.\r\n\t\t//\r\n\t\t// Returns a Number, the lcm.\r\n\t\tlcm: function() {\r\n\t\t\t// Create a new stats object to work with\r\n\t\t\tvar nums = this.clone();\r\n\r\n\t\t\t// Go through each element and make the element the lcm of it\r\n\t\t\t// and the element to its left\r\n\t\t\tfor (var i = 1; i < nums.size(); i++) {\r\n\t\t\t\tnums.set(i, lcm(nums.get(i - 1), nums.get(i)));\r\n\t\t\t}\r\n\r\n\t\t\t// The lcm of all the numbers if now in the final element\r\n\t\t\treturn nums.get(nums.size() - 1);\r\n\t\t}\r\n\t};\r\n\r\n\t// Private. Calculates the gcd of two numbers using Euclid's method.\r\n\t//\r\n\t// Returns a Number.\r\n\tfunction gcd(a, b) {\r\n\t\tif (b === 0) {\r\n\t\t\treturn a;\r\n\t\t}\r\n\r\n\t\treturn gcd(b, a - b * Math.floor(a / b));\r\n\t}\r\n\r\n\t// Private. Calculates the lcm of two numbers.\r\n\t//\r\n\t// Returns a Number.\r\n\tfunction lcm(a, b) {\r\n\t\t// The least common multiple is the absolute value of the product of\r\n\t\t// the numbers divided by the greatest common denominator\r\n\t\treturn Math.abs(a * b) / gcd(a, b);\r\n\t}\r\n\r\n\t// Provide built in JavaScript array mutator methods for the data list\r\n\tvar mutators = ['pop', 'push', 'shift', 'splice', 'unshift'];\r\n\tfor (var i = 0; i < mutators.length; i++) {\r\n\t\tstats.init.prototype[mutators[i]] = (function(method) {\r\n\t\t\treturn function() {\r\n\t\t\t\treturn Array.prototype[method].apply(\r\n\t\t\t\t\tthis.arr,\r\n\t\t\t\t\tArray.prototype.slice.call(arguments, 0)\r\n\t\t\t\t);\r\n\t\t\t};\t\r\n\t\t})(mutators[i]);\r\n\t}\r\n\r\n\t// Provide built in JavaScript array accessor methods for the data list\r\n\tvar accessors = ['concat', 'join', 'slice', 'reverse'];\r\n\tfor (var i = 0; i < accessors.length; i++) {\r\n\t\tstats.init.prototype[accessors[i]] = (function(method) {\r\n\t\t\treturn function() {\r\n\t\t\t\tthis.arr = Array.prototype[method].apply(\r\n\t\t\t\t\tthis.arr,\r\n\t\t\t\t\tArray.prototype.slice.call(arguments, 0)\r\n\t\t\t\t);\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t};\t\r\n\t\t})(accessors[i]);\r\n\t}\r\n\r\n\t// Override the built-in #toJSON() and #toArray() methods\r\n\tstats.init.prototype.toJSON = stats.init.prototype.toArray = function() {\r\n\t\treturn this.arr;\r\n\t};\r\n\r\n\t// Creates a list from the specified lower bound to the specified upper\r\n\t// bound.\r\n\t//\r\n\t// lower - The lower bound.\r\n\t// upper - The upper bound.\r\n\t// step  - The amount to count by.\r\n\t//\r\n\t// Returns a new stats object.\r\n\tstats.list = function(lower, upper, step) {\r\n\t\t// Create the array\r\n\t\tvar arr = [];\r\n\t\tfor (var i = lower; i <= upper; i += step || 1) {\r\n\t\t\tarr[i - lower] = i;\r\n\t\t}\r\n\r\n\t\treturn stats(arr);\r\n\t};\r\n\r\n\t// Computes the factorial of a number.\r\n\t//\r\n\t// num - The number.\r\n\t//\r\n\t// Returns the factorial.\r\n\tstats.factorial = function(num) {\r\n\t\t// Handle the special case of 0\r\n\t\tif (num === 0) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// Otherwise compute the factorial\r\n\t\tfor (var i = num - 1; i > 1; i--) {\r\n\t\t\tnum *= i;\r\n\t\t}\r\n\r\n\t\treturn num;\r\n\t};\r\n\r\n\t// Computes a permutation.\r\n\t//\r\n\t// n - The length of the set.\r\n\t// r - The number of elements in the subset.\r\n\t//\r\n\t// Returns the permutation.\r\n\tstats.permutation = stats.nPr = function(n, r) {\r\n\t\treturn stats.factorial(n) / stats.factorial(n - r);\r\n\t};\r\n\r\n\t// Computes a combination.\r\n\t//\r\n\t// n - The length of the set.\r\n\t// r - The number of elements in the subset.\r\n\t//\r\n\t// Returns the combination.\r\n\tstats.combination = stats.nCr = function(n, r) {\r\n\t\treturn stats.factorial(n) /\r\n\t\t\t(stats.factorial(r) * stats.factorial(n - r));\r\n\t};\r\n\r\n\t// Computes the probability of a binomial event.\r\n\t//\r\n\t// trials - The number of trials.\r\n\t// p      - The probability of success.\r\n\t// x      - The event number (optional).\r\n\t//\r\n\t// If x is not passed, an array with all the probabilities\r\n\t// will be returned.\r\n\t//\r\n\t// Returns a number or an array.\r\n\tstats.binompdf = function(trials, p, x) {\r\n\t\t// CASE: Specific event was passed\r\n\t\tif (x != null) {\r\n\t\t\t// Return 0 if the event does not exist\r\n\t\t\tif (x > trials || x < 0) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Return the probability otherwise\r\n\t\t\treturn stats.nCr(trials, x) * Math.pow(p, x) *\r\n\t\t\t\tMath.pow(1 - p, trials - x);\r\n\t\t}\r\n\t\t// CASE: No specific event was passed\r\n\t\telse {\r\n\t\t\t// Compute the probabilities\r\n\t\t\treturn stats.list(0, trials).map(function(num) {\r\n\t\t\t\treturn stats.binompdf(trials, p, num);\r\n\t\t\t}).toArray();\r\n\t\t}\r\n\t};\r\n\r\n\t// Computes the cumulative probability of a binomial event.\r\n\t//\r\n\t// trials - The number of trials.\r\n\t// p      - The probability of success.\r\n\t// x      - The upper bound (inclusive).\r\n\t//\r\n\t// Returns the probability.\r\n\tstats.binomcdf = function(trials, p, x) {\r\n\t\treturn stats.list(0, x).map(function(num) {\r\n\t\t\treturn stats.binompdf(trials, p, num);\r\n\t\t}).sum();\r\n\t};\r\n\r\n\t// Computes the probability of a geometric event.\r\n\t//\r\n\t// p - The probability of success.\r\n\t// x - The event number.\r\n\t//\r\n\t// Returns the probability.\r\n\tstats.geompdf = function(p, x) {\r\n\t\treturn Math.pow(1 - p, x - 1) * p;\r\n\t};\r\n\r\n\t// Computes the cumulative probability of a geometric event.\r\n\t//\r\n\t// p - The probability of success.\r\n\t// x - The event number.\r\n\t//\r\n\t// Returns the probability.\r\n\tstats.geomcdf = function(p, x) {\r\n\t\treturn stats.list(1, x).map(function(num) {\r\n\t\t\treturn stats.geompdf(p, num);\r\n\t\t}).sum();\r\n\t};\r\n\r\n\t// Computes the normal probability of an event.\r\n\t//\r\n\t// x     - The event number.\r\n\t// mu    - The mean.\r\n\t// sigma - The standard deviation.\r\n\t//\r\n\t// Returns the probability.\r\n\tstats.normalpdf = function(x, mu, sigma) {\r\n\t\treturn (1 / (sigma * Math.sqrt(2 * Math.PI))) *\r\n\t\t\tMath.exp(-1 * (x - mu) * (x - mu) /\r\n\t\t\t(2 * sigma * sigma));\r\n\t};\r\n\r\n\t// Computes the cumulative normal probability of an event.\r\n\t//\r\n\t// x - The event number.\r\n\t// mu - The mean.\r\n\t// sigma - The standard deviation.\r\n\t//\r\n\t// If four parameters are passed the first two are taken as the\r\n\t// low and high.\r\n\t//\r\n\t// Returns the probability.\r\n\tstats.normalcdf = function(x, mu, sigma) {\r\n\t\t// If four parameters were passed, return the difference of\r\n\t\t// the probabilities of the upper and lower\r\n\t\tif (arguments.length === 4) {\r\n\t\t\t// The cumulative probability is the difference of the\r\n\t\t\t// probabilities of the upper and the lower\r\n\t\t\treturn stats.normalcdf(arguments[1], arguments[2], arguments[3]) -\r\n\t\t\t\tstats.normalcdf(arguments[0], arguments[2], arguments[3]);\r\n\t\t}\r\n\r\n\r\n\t\t// Convert the event to a z score\r\n\t\tvar z = (x - mu) / sigma;\r\n\r\n\t\t// The probability will be stored here\r\n\t\tvar p;\r\n\r\n\t\t// Coefficients\r\n\t\tvar p0 = 220.2068679123761;\r\n\t\tvar p1 = 221.2135961699311;\r\n\t\tvar p2 = 112.0792914978709;\r\n\t\tvar p3 = 33.91286607838300;\r\n\t\tvar p4 = 6.373962203531650;\r\n\t\tvar p5 = .7003830644436881;\r\n\t\tvar p6 = .03526249659989109;\r\n\r\n\t\tvar q0 = 440.4137358247522;\r\n\t\tvar q1 = 793.8265125199484;\r\n\t\tvar q2 = 637.3336333788311;\r\n\t\tvar q3 = 296.5642487796737;\r\n\t\tvar q4 = 86.78073220294608;\r\n\t\tvar q5 = 16.06417757920695;\r\n\t\tvar q6 = 1.755667163182642;\r\n\t\tvar q7 = .08838834764831844;\r\n\r\n\t\t// Another coefficient (10/sqrt(2))\r\n\t\tvar cutoff = 7.071;\r\n\r\n\t\t// Cache the absolute value of the z score\r\n\t\tvar zabs = Math.abs(z);\r\n\r\n\t\t// If you're more than 37 z scores away just return 1 or 0\r\n\t\tif (z > 37) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (z < -37) {\r\n\t\t\treturn 0.0;\r\n\t\t}\r\n\r\n\t\t// Compute the normalpdf of this event\r\n\t\tvar exp = Math.exp(-.5 * zabs * zabs);\r\n\t\tvar pdf = exp / Math.sqrt(2 * Math.PI);\r\n\r\n\t\t// Compute the probability\r\n\t\tif (zabs < cutoff) {\r\n\t\t\tp = exp*((((((p6*zabs + p5)*zabs + p4)*zabs + p3)*zabs +\r\n\t\t\t\tp2)*zabs + p1)*zabs + p0)/(((((((q7*zabs + q6)*zabs +\r\n\t\t\t\tq5)*zabs + q4)*zabs + q3)*zabs + q2)*zabs + q1)*zabs +\r\n\t\t\t\tq0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tp = pdf/(zabs + 1.0/(zabs + 2.0/(zabs + 3.0/(zabs + 4.0/\r\n\t\t\t\t(zabs + 0.65)))));\r\n\t\t}\r\n\r\n\t\tif (z < 0.0) {\r\n\t\t\treturn p;\r\n\t\t} else {\r\n\t\t\treturn 1 - p;\r\n\t\t}\r\n\t};\r\n\r\n\t// Computes the inverse normal.\r\n\t//\r\n\t// p - The probability of x being less than or equal to *x*, the value we\r\n\t//     are looking for.\r\n\t//\r\n\t// Returns the x value.\r\n\tstats.invNorm = function(p) {\r\n\t\t// Coefficients for the rational approximation\r\n\t\tvar a = [\r\n\t\t\t-3.969683028665376e+01,\r\n\t\t\t 2.209460984245205e+02,\r\n\t\t\t-2.759285104469687e+02,\r\n\t\t\t 1.383577518672690e+02,\r\n\t\t\t-3.066479806614716e+01,\r\n\t\t\t 2.506628277459239e+00\r\n\t\t];\r\n\t\tvar b = [\r\n\t\t\t-5.447609879822406e+01,\r\n\t\t\t 1.615858368580409e+02,\r\n\t\t\t-1.556989798598866e+02,\r\n\t\t\t 6.680131188771972e+01,\r\n\t\t\t-1.328068155288572e+01\r\n\t\t];\r\n\t\tvar c = [\r\n\t\t\t-7.784894002430293e-03,\r\n\t\t\t-3.223964580411365e-01,\r\n\t\t\t-2.400758277161838e+00,\r\n\t\t\t-2.549732539343734e+00,\r\n\t\t\t 4.374664141464968e+00,\r\n\t\t\t 2.938163982698783e+00\r\n\t\t];\r\n\t\tvar d = [\r\n\t\t\t7.784695709041462e-03,\r\n\t\t\t3.224671290700398e-01,\r\n\t\t\t2.445134137142996e+00,\r\n\t\t\t3.754408661907416e+00\r\n\t\t];\r\n\r\n\t\t// Breakpoints\r\n\t\tvar pLow = .02425;\r\n\t\tvar pHigh = 1 - pLow;\r\n\r\n\t\t// Rational appoximation for the lower region\r\n\t\tif (0 < p && p < pLow) {\r\n\t\t\tvar q = Math.sqrt(-2 * Math.log(p));\r\n\t\t\treturn (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /\r\n\t\t\t\t((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) *q + 1);\r\n\t\t}\r\n\t\telse if (pLow <= p && p <= pHigh) {\r\n\t\t\tvar q = p - 0.5;\r\n\t\t\tvar r = q * q;\r\n\t\t\treturn (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /\r\n\t\t\t\t(((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);\r\n\t\t}\r\n\t\telse if (pHigh < p && p < 1) {\r\n\t\t\tvar q = Math.sqrt(-2 * Math.log(1 - p));\r\n\t\t\treturn -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /\r\n\t\t\t\t((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);\r\n\t\t}\r\n\t};\r\n\r\n\t// Runs a 1-mean z-test.\r\n\t//\r\n\t// muZero     - The proposed population mean.\r\n\t// sigma      - The standard deviation of the population.\r\n\t// xBar       - The sample mean.\r\n\t// n          - The sample size.\r\n\t// inequality - One of \"notequal\", \"lessthan\", or \"greaterthan\", depending\r\n\t//              on what you're testing \r\n\t//\r\n\t// Returns an object with the z-test statistic (z) and P-value (p).\r\n\tstats.ZTest = function(muZero, sigma, xBar, n, inequality) {\r\n\t\t// Calculate the z-test statistic\r\n\t\tvar z = (xBar - muZero) / (sigma / Math.sqrt(n));\r\n\t\t\r\n\t\t// Calculate the P-value\r\n\t\tvar p;\r\n\t\tif (z < 0) {\r\n\t\t\t// Use normalcdf from -infinity to the z statistic\r\n\t\t\tp = stats.normalcdf(-Infinity, z, 0, 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Use normalcdf from the z statistic to +infinity\r\n\t\t\tp = stats.normalcdf(z, Infinity, 0, 1);\r\n\t\t}\r\n\r\n\t\t// Multiply the P-value by two if you're doing a not equal test\r\n\t\tif (inequality === 'notequal') {\r\n\t\t\tp *= 2;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tz: z,\r\n\t\t\tp: p\r\n\t\t};\r\n\t};\r\n\r\n\t// Computes a 1-mean z-interval.\r\n\t//\r\n\t// sigma - The population standard deviation.\r\n\t// xBar  - The sample mean.\r\n\t// n     - The sample size.\r\n\t// level - The confidence level (between 0 and 1, exclusive).\r\n\t//\r\n\t// Returns an object with the low, high, and margin of error (moe).\r\n\tstats.ZInterval = function(sigma, xBar, n, level) {\r\n\t\t// Compute the margin of error\r\n\t\tvar moe = -stats.invNorm((1 - level) / 2) * sigma / Math.sqrt(n);\r\n\r\n\t\treturn {\r\n\t\t\tlow: xBar - moe,\r\n\t\t\thigh: xBar + moe,\r\n\t\t\tmoe: moe\r\n\t\t};\r\n\t};\r\n\r\n\t// Export the stats object\r\n\t// =================================================\r\n\tif (true) {\r\n\t\t// Expose to AMD loaders\r\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n\t\t\treturn stats;\r\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else {}\r\n}(this));\n\n//# sourceURL=webpack:///../node_modules/statsjs/lib/stats.js?");

/***/ })

}]);